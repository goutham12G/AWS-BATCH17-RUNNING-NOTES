    IF SHELL SCRIPTING IS ALREADY THERE, WHY PYTHON?

    --------------------------------------------------
    SHELL SCRIPTING (WHAT IT IS)
    --------------------------------------------------

        - A command-line interpreter and scripting language for Unix/Linux systems.
        - Mainly used to automate Linux commands and OS-level tasks.
        - Ideal for:
              • File operations
              • System administration
              • Package installation
              • Cron jobs
              • Service management
        - Not designed for complex programming.
        - Works best only on Unix-like systems (Linux, macOS).
        - Windows uses PowerShell instead, not Bash.


    --------------------------------------------------
    WHY PYTHON IS NEEDED (EVEN IF SHELL EXISTS)
    --------------------------------------------------

        - Python is a full programming language.
        - Handles complex automation that shell cannot.
        - Required for modern DevOps automation:
              • AWS / Azure / GCP automation
              • CI/CD integrations
              • API-based automation
              • CloudOps scripting
        - Cross-platform (Linux, Windows, macOS)
        - Easy to learn, clean syntax, very powerful.
        - Faster automation with fewer lines of code.

        Summary:
            Shell → OS-level automation (Low level automation)
            Python → High-level automation + APIs + DevOps tools


    --------------------------------------------------
    PYTHON (WHAT IT IS)
    --------------------------------------------------

        - A high-level, general-purpose programming language.
        - Clean and readable syntax.
        - Supports multiple paradigms:
              • Object-Oriented
              • Functional
              • Procedural
        - Used for:
              • Web development
              • Data analysis
              • Machine learning
              • DevOps automation (scope of our course) 
              • Scientific computing

        DevOps scope:
            Python scripting + API automation only.

        OOP Concepts supported:
            - Classes
            - Objects
            - Inheritance
            - Encapsulation
            - Polymorphism
            - Abstraction


    --------------------------------------------------
    WHAT IS A PROGRAM?
    --------------------------------------------------

        - A collection of instructions written in code.
        - Passed to computer --> CPU → Processor executes instructions.
        - Programs manipulate data.
        - Data is stored using variables.


    --------------------------------------------------
    WHAT IS A VARIABLE?
    --------------------------------------------------

        - A container used to store data.
        - Example:

              x = "madhu"
              x = 10
              x = 10.3
              x = 3+4j


    --------------------------------------------------
    WHAT IS A DATA TYPE?
    --------------------------------------------------

        - Defines what type of value a variable stores.

        Common types:
            Text      → str
            Numeric   → int, float, complex
            Boolean   → bool (True/False)

        Collection types (can store multiple values):
            list, tuple, set, dictionary


        Example:
            X = [10, 9.8, "KIRAN", True] 


    --------------------------------------------------
    READING INPUT & PRINTING OUTPUT
    --------------------------------------------------

        In Linux (shell):

            echo "Enter your name"
            read name
            echo "Value of name is $name"

        In Python:

            name = input("Enter your name: ")
            print(f"Hello,", {name})

        Shell script example:

            #!/bin/bash
            read -p "Enter your name: " name
            echo "Hello, $name"


    --------------------------------------------------
    OPERATORS
    --------------------------------------------------

        Arithmetic:
            +  -  *  /  %

        Assignment:
            =  +=  -=  *=
			
			a = 10
			a+=2  --> a = a + 2
			

        Comparison:
            <  >  <=  >=  ==  !=
            Shell equivalents: -eq -lt -le -gt -ge

        Logical:
            and, or, not

        Identity:
            is, is not

        Membership:
            in, not in

        Bitwise:
            & | ^ ~


    --------------------------------------------------
    PYTHON EXAMPLE
    --------------------------------------------------

        num1 = float(input("Enter first number: "))
        num2 = float(input("Enter second number: "))

        sum = num1 + num2

        print(f"The sum of {num1} and {num2} is: {sum}")


    --------------------------------------------------
    SHELL EXAMPLE
    --------------------------------------------------

        #!/bin/bash
		
		echo "ENter numer 1"
        read num1
		
	    echo "ENter numer 2"
        read num2
		
        sum=$((num1+num2))
        echo "Sum of 2 numbers : $sum"


    --------------------------------------------------
    ADVANCED DATA TYPES (COLLECTION TYPES)
    --------------------------------------------------

     x = [ 10, madhu, 5.3, 4+3i ]

        List:
            - Ordered
            - Mutable
            - Allows duplicates
            list = [1, 2, 3, 1]

        Tuple:
            - Ordered
            - Immutable
            - Allows duplicates
            tuple = (1, 2, 3, 1)

        Set:
            - Unordered
            - No duplicates
            - No index
			- unique values 
			
            set = {1, 2, 3}

        Dictionary:
            - Unordered
            - Mutable
            - Key-value pairs
            dict = {
			         "name": "Madhu", 
			         "age": 30
					 "address: "xyz"
                     "prof" : "abc" 

					 }


    --------------------------------------------------
    REAL DEVOPS EXAMPLES
    --------------------------------------------------



Real-Time DevOps Examples 

List:

Server IPs: 
       A list of IP addresses of servers in a Cluster, which may change as servers are added or removed.

   - Server IPs: ['192.168.3.2', '192.168.1.2', '10.81.0.3'] 

   
==============================


Tuple:

Server Configuration: 
          A tuple containing details of server configuration  (IP, OS, version). These values are fixed Once set, these details should not change.
		  
          Immutable System Settings: Information about the region, availability zone, and instance type, which remains constant for the duration of a deployment.
		  
   - Server Configuration: ('192.168.1.1', 'Ubuntu', '18.04') 
   - Immutable System Settings: ('US-East', 'us-east-1a', 'm5.large')		  
		  
====================
	  
Set:

    Active Services --- A set of active services running on a server, where uniqueness (no duplicates) is crucial.
	
    Unique Error Codes ---A set of unique error codes encountered during operations, useful for monitoring and alerting.

	- Active Services: {'nginx', 'redis', 'mysql', 'jenkins'} 
	- Unique Error Codes: {404, 500, 502}
	
=====================

Dictionaries :	
	
    Environment Variables: Key-value pairs representing environment variables for an application, where keys are unique and values can vary.
	
    Configurations: Dictionary of configurations, such as timeout settings and retry limits, where keys represent the setting and values are the parameters

    - Environment Variables: {
	                          'DB_HOST': 'mcdb.example.com', 
	                           'DB_USER': 'admin'
							   
							   
							   } 
	
    - Configurations: {
	
	                   'timeout': 30, 
					   'retries': 3
					   }
					   
					   
	    dict = {
			         "name": "Madhu", 
			         "age": 30
					 "address: "xyz"
                     "prof" : "abc" 

					 }


========================================================

        LIST
            Server IPs:
                ["192.168.1.1", "192.168.1.2", "10.81.0.3"]

        TUPLE
            Immutable server config:
                ("192.168.1.1", "Ubuntu", "18.04")

        SET
            Active services:
                {"nginx", "redis", "mysql"}

            Unique error codes:
                {404, 500, 502}

        DICTIONARY
            Environment variables:
                {"DB_HOST": "db.example.com", "DB_USER": "admin"}

            Configurations:
                {"timeout": 30, "retries": 3}


==================================================

    --------------------------------------------------
    PRACTICAL EXAMPLES
    --------------------------------------------------

        Remove duplicates from list:

            usernames = ["madhu", "kiran", "madhu", "raja" ]
            unique = list(set(usernames))

        Contact book:

            contact = {
                "name": "Madhu",
                "phone": "73966",
                "email": "devops@gmail.com"
            }

            contact_book = [
     
                {"name": "xyz",   "phone": "...","email": "abc@gmail.com"},
				{                                                        },
				{"name": "Madhu", "phone": "...", "email": "abc@gmail.com"},
            ]

===============================================================================

========================================================


	FUNCTIONS 
          -- BLOCK OF CODE FOR REPEATED USE 
		  -- ALLOWS TO GROUP A SET OF COMMANDS INTO A SINGLE, REUSABLE UNIT. 
		  -- BREAK DOWN TOTAL FUNCTIONALITY OF SCRIPT INTO LOGICAL SUB-SECTIONS 
          -- ENCAPSULATE AND REUSE CODE
		  -- WE CAN CALL FUNCTIONS WHEN EVER NEEDED
		  -- MAKE YOUR SCRIPTS MORE ORGANIZED, MODULAR, AND EASIER TO MAINTAIN.
		  
	

============================================================

FUNCTIONS IN PYTHON: 

# Python example

def greet(name):
    print(f"Hello, {name}!")

greet("Madhu")	

====================================================================


FUNCTIONS IN SHELL : 
# Bash example

greet() {
  echo "Hello, $1!"
}

greet "Madhu"

greet "kiran"

=================================


LINUX :

yum install python -y 
apt install python -y 

WINDOWS: 

DOWNLOAD & INSTALL 
================================================================

DATE:
17 JAN 26


PYTHON VS SHELL, FUNCTIONS, AND DATA TYPES (NOTES)

    --------------------------------------------------
    PYTHON TRACING (DEBUGGING)
    --------------------------------------------------

        Run script with tracing:

            python3 -m trace --trace script.py


    --------------------------------------------------
    SHELL FUNCTION EXAMPLE
    --------------------------------------------------

        #!/bin/bash

        greet() {
            echo "Hello, $1!"
        }

        greet "Madhu"
        greet "Kiran"


    --------------------------------------------------
    PYTHON FUNCTION EXAMPLE
    --------------------------------------------------

        def greet(name):
            print(f"Hello, {name}!")

        greet("Madhu")
        greet("Kiran")


    --------------------------------------------------
    SHELL FUNCTION WITH set -x (DEBUGGING)
    --------------------------------------------------

        #!/bin/bash

        set -x
        sum() {
            result=$(( $1 + $2 ))
            echo "The sum of $1 and $2 is $result"
        }

        sum 5 10
        sum 20 30
        sum 100 250


    --------------------------------------------------
    PYTHON SUM FUNCTION
    --------------------------------------------------

        def sum(a, b):
            result = a + b
            print(f"The sum of {a} and {b} is {result}")

        sum(5, 10)
        sum(20, 30)
        sum(100, 250)


    --------------------------------------------------
    PYTHON FUNCTION WITH RETURN
    --------------------------------------------------

        def add_numbers(a, b):
            result = a + b
            return result

        num1 = float(input("Enter first number: "))
        num2 = float(input("Enter second number: "))

        sum_result = add_numbers(num1, num2)
        print(f"The sum of {num1} and {num2} is {sum_result}")


    ==================================================
    LIST OPERATIONS USING FUNCTIONS & METHODS :
    ==================================================

        my_list = [1, 2, 3, 4, 5]

        my_list.append(4)
        print("After append:", my_list)

        my_list.extend([8, 9, 7])
        print("After extend:", my_list)

        my_list.insert(0, 10)
        print("After insert:", my_list)

        my_list.remove(1)
        print("After remove:", my_list)

        popped_element = my_list.pop()
        print("Popped element:", popped_element)
        print("After pop:", my_list)

        index_of_9 = my_list.index(9)
        print("Index of 9:", index_of_9)

        count_of_1 = my_list.count(1)
        print("Count of 1:", count_of_1)

        my_list.sort()
        print("After sort:", my_list)

        my_list.reverse()
        print("After reverse:", my_list)

        copied_list = my_list.copy()
        print("Copied list:", copied_list)

        my_list.clear()
        print("After clear:", my_list)

        print("Length of list:", len(my_list))
        print("Length of copied list:", len(copied_list))
        print("Maximum:", max(copied_list))
        print("Minimum:", min(copied_list))
        print("Sum:", sum(copied_list))


    ==================================================
    TUPLE – OPERATIONS (IMMUTABLE)
    ==================================================
	
	Immutability: Tuples cannot be modified once created. 

    Methods like append(), remove(), pop(), etc., are not available.

        my_tuple = (3, 1, 4, 1, 5, 9, 2, 6, 5)

        count_of_1 = my_tuple.count(1)
        print("Count of 1:", count_of_1)

        index_of_9 = my_tuple.index(9)
        print("Index of 9:", index_of_9)

        print("Length:", len(my_tuple))
        print("Max:", max(my_tuple))
        print("Min:", min(my_tuple))
        print("Sum:", sum(my_tuple))

        sorted_list = sorted(my_tuple)
        print("Sorted tuple as list:", sorted_list)

        sorted_list.append(4)
        print("After append:", sorted_list)


    ==================================================
    SETS – OPERATIONS (NO DUPLICATES)
    ==================================================
    No Duplicate Elements:   Sets automatically remove duplicate elements.
    Unordered: Sets do not maintain the order of elements.
    Mutable: You can add or remove elements from a set.
	Use Cases: Sets are useful for removing duplicates from a collection, checking for membership, and performing set operations like union, intersection, and difference.


        my_set = {1, 2, 3, 4, 5}

        my_set.add(6)
        print("After add:", my_set)

        my_set.remove(4)
        print("After remove:", my_set)

        popped = my_set.pop()
        print("Popped:", popped)
        print("After pop:", my_set)

        my_set.clear()
        print("After clear:", my_set)

        set_a = {1, 2, 3}
        set_b = {3, 4, 5}

        print("Union:", set_a.union(set_b))
        print("Intersection:", set_a.intersection(set_b))
        print("Difference:", set_a.difference(set_b))


    ==================================================
    DICTIONARIES – OPERATIONS
    ==================================================

        my_dict = {
            "name": "Madhu",
            "phone": "7396627149",
            "city": "Hyderabad"
        }

        print("Name:", my_dict['name'])

        phone = my_dict.get('phone')
        print("Phone:", phone)

        salary = my_dict.get('salary', 'Not Available')
        print("Salary:", salary)

        my_dict['occupation'] = 'DevOps Engineer'
        print("After adding occupation:", my_dict)

        popped_value = my_dict.pop('phone')
        print("Popped:", popped_value)
        print("After pop:", my_dict)

        print("Keys:", list(my_dict.keys()))
        print("Values:", list(my_dict.values()))
        print("Items:", list(my_dict.items()))

        my_dict.clear()
        print("After clear:", my_dict)

        new_dict = {'a': 1, 'b': 2}
        copied_dict = new_dict.copy()
        print("Copied:", copied_dict)


======================================
    FUNCTIONS VS METHODS IN PYTHON

    --------------------------------------------------
    WHAT IS A FUNCTION?
    --------------------------------------------------

        A function is a standalone block of code that:

            - Is not tied to any object
            - Takes data as arguments
            - Returns a result

        Examples (built-in functions):

            len(my_list)
            max(my_list)
            sum(my_list)

        General form:

            function_name(data)

        Your examples:

            len(my_list)
            max(copied_list)
            min(copied_list)
            sum(copied_list)

        These:

            ✔ Work on data you pass
            ✔ Do NOT belong to the data itself (not part of list)


    --------------------------------------------------
    WHAT IS A METHOD?
    --------------------------------------------------

        A method is a function that belongs to an object.

        In Python:

            - Methods are defined inside a class
            - They are called using an object

        Examples:

            my_list.append(4)
            my_list.sort()

        General form:

            object.method(arguments)

        Your examples:

            my_list.append(4)
            my_list.extend([8, 9, 7])
            my_list.insert(0, 10)
            my_list.remove(1)
            my_list.pop()
            my_list.sort()
            my_list.reverse()
            my_list.copy()
            my_list.clear()

        These:

            ✔ Belong to the list object
            ✔ Know how to modify the list


    --------------------------------------------------
    WHY append() IS NOT A FUNCTION
    --------------------------------------------------

        This will fail:

            append(my_list, 4)     (❌ invalid)

        Because append is a method defined inside the list class.

        Correct usage:

            my_list.append(4)


    --------------------------------------------------
    WHY len() IS NOT A METHOD
    --------------------------------------------------

        This will fail:

            my_list.len()      (❌ invalid)

        Because len() is a built-in function, not a method.

        Correct:

            len(my_list)


    --------------------------------------------------
    USAGE:
    --------------------------------------------------

        Function:

            function(data)
			greet(name)
			sum (num1, num2))

        Method:

            data.method()
            mylist.append()



    --------------------------------------------------
    WHY PYTHON HAS BOTH
    --------------------------------------------------

        Functions:
            - Generic
            - Work on many data types
            - Examples: len(), type(), sum()

        Methods:
            - Specific to a particular data type
            - Modify or act on that object
            - Examples: list.append(), str.upper()


    --------------------------------------------------
    FUNCTION VS METHOD (SIDE-BY-SIDE)
    --------------------------------------------------

        Feature                     Function        Method
        ----------------------------------------------------
        Belongs to object          No              Yes
        Called using               function(x)     x.method()
        Defined in                 Global/module   Class
        Needs object               Passed          Implicit (self)
        Example                    len(x)          x.append(4)


    --------------------------------------------------
    CLASSIFICATION OF YOUR CODE
    --------------------------------------------------

        LIST METHODS (object methods):

            append()
            extend()
            insert()
            remove()
            pop()
            index()
            count()
            sort()
            reverse()
            copy()
            clear()

        BUILT-IN FUNCTIONS:

            len()
            max()
            min()
            sum()


    --------------------------------------------------
    FINAL TAKEAWAY (MEMORIZE THIS)
    --------------------------------------------------

        If you call it like:

            object.something()

        → It is a METHOD.

        If you call it like:

            something(object)

        → It is a FUNCTION.


====================================================================================

x = 10
x = "madhu"
x = 10.2
x = 4 + 3j


STATICALLY TYPED  VS DYNAMIC TYPED 
Dynamic typing means that the type of a variable is determined at runtime, not in advance. You do not need to declare the type of a variable when you create it. 


Static typing means that the type of a variable is known at compile time. You must declare the type of a variable before you use it, and this type cannot change throughout the program. Languages like C, C++, go  and Java are statically typed.

======================================================================

DATE: 19 JAN 26


STRING MANIPULATION WITH in built METHONS /FUNCTIONS in python :



my_string = "Hello, Welcome to Aws Devops World"

# 1. Length of the string
print(f"Length of the string: {len(my_string)}")

# 2. Convert to uppercase and lowercase
print(f"Uppercase: {my_string.upper()}")
print(f"Lowercase: {my_string.lower()}")

# 3. Count occurrences of a substring
substring = "Welcome"
print(f"Occurrences of '{substring}': {my_string.count(substring)}")

# 4. Check if the string starts or ends with a particular substring
print(f"Starts with 'Hello': {my_string.startswith('Hello')}")
print(f"Ends with 'World.': {my_string.endswith('World')}")

# 5. Find the index of a substring (first occurrence)
print(f"Index of 'World': {my_string.find('World')}")

# 6. Replace a substring with another substring
new_string = my_string.replace('Aws', 'Cloud')
print(f"Original string: {my_string}")
print(f"Modified string: {new_string}")

# 7. Split the string into a list based on a delimiter
words = my_string.split()
print(f"Split into words: {words}")

# 8. Check if all characters are alphanumeric
alphanumeric_string = "Python123"
print(f"Is Python123 alphanumeric? {alphanumeric_string.isalnum()}")

# 9. Convert string to title case
title_case_string = "python programming"
print(f"Title case: {title_case_string.title()}")


=================================================================



# Integer examples
x = 10
y = -5
z = 0

# Floating-point examples
a = 3.14
b = -0.001


# Print examples
print(f"Integers: x = {x}, y = {y}, z = {z}")
print(f"Floating-point numbers: a = {a}, b = {b}, c = {c}")


# Arithmetic operations
print(f"\nArithmetic Operations:")
print(f"x + y = {x + y}")   # Addition
print(f"x - y = {x - y}")   # Subtraction
print(f"x * y = {x * y}")   # Multiplication
print(f"x / y = {x / y}")   # Division
print(f"x % y = {x % y}")   # Modulus


# Type conversions
print(f"\nType Conversions:")
f = float(x)
print(f"Convert int {x} to float: f = {f}")

g = int(a)
print(f"Convert float {a} to int: g = {g}")




=================================================================

CONDITIONAL EXPRESSION : 


=================================================================

if condition1:
    # Block of code to execute if condition1 is True
   
elif condition2:
    # Block of code to execute if condition1 is False and condition2 is True
   
elif condition3:
    # Block of code to execute if previous conditions are False and condition3 is True
	
elif condition4:
    # Block of code to execute if previous conditions are False and condition4 is True	
   
else:
    # Block of code to execute if all previous conditions are False
   
=================================================================
cat if.sh

#!/bin/bash


read -p "Enter a number: " NUMBER

if [ $NUMBER -gt 10 ]; then
    echo "$NUMBER is greater than 10"

elif [ $NUMBER -lt 10  ]; then
    echo "$NUMBER is less than 10"

else
    echo "$NUMBER is equal to 10"

fi
=================================================================

$ cat if.py

number = float(input("Enter a number: "))

if number > 10:
    print(f"{number} is greater than 10")

elif number < 10:
    print(f"{number} is less than 10")

else:
    print(f"{number} is equal to 10")
	
	
===================================================================

PYTHON LOOPS :
      
WHILE 
FOR 

	 
	  
WHILE  LOOP:

  it enables you to execute set of commands as long as conndition is true . 
  
  once condition fails , it comes out of loop .
 
-------------------------------------------------------------------

#!/bin/bash

i=0

while [ "$i" -lt 101 ]; do
    echo "Iteration number: $i"
    ((i++))
done

echo "Loop finished!"

 
-------------------------------------------------------------------

cat while.py

i = 0 

while i < 101:
    print("Iteration number:", i)
    i = i + 1 

print("Loop finished!")
	
-------------------------------------------------------------------
BREAK & CONTINUE :

In Python, break and continue are control flow statements used inside loops (for and while). They help control the flow of loop execution based on certain conditions


**a. break Statement:

Used to exit the loop prematurely.



**b. continue Statement:

Skips the rest of the current iteration and proceeds to the next iteration of the loop.


-------------------------------------------------------------------
BREAK :


i = 0 

while i < 101:
    print("Iteration number:", i)

    if i == 5:
        print("Reached 5, breaking the loop.")
        break
    

    i = i + 1 

print("Loop finished!")
-------------------------------------------------------------------

CONTIUE: 


i = 0 

while i < 101:

    if i == 5:
        i += 1
        continue
    
    print("Iteration number:", i)

    i = i + 1 

print("Loop finished!")

==============================================================================

FOR LOOP : 

For loop operates on list of items , it repeats commands on every item in the list 

----------------
for variable in iterable:
    # Block of code to execute
    statement1
    statement2
    # More statements
	
	

-----------------------------------


mc_list = [1,2,3,4,5,6,7,8,9,10]

for mc in mc_list:
    print(f"Processing mc value: {mc}") 
    

-----------------------------------

for i in range(50,101):
    print("Iteration number:", i)



------------------   ### range(n) ---> 0 - n-1
for i in range(5):    
    print(i)

----------------

for number in range(1, 11):  ### range(k, n) ---> k ... n-1
    print(number)

----------------

fruits = ["apple", "banana", "cherry"]

for fruit in fruits:
    print(fruit)


=======================================================

def add(a,b):
    return a + b 

result = add(3, 5)
print(result)  

================================================================
LAMBDA : 

lambda arguments: expression

   - a lambda function is a small, anonymous function defined using the lambda keyword. 
   
   
    lambda: Keyword to define an anonymous function.
    arguments: The input parameters to the function.
    expression: A single expression that the function returns.
	
================================================================	
cat lambda.py


sum = lambda a, b: a + b

print("Sum of 5 and 3 is:", sum(5, 3))
print("Sum of 10 and 20 is:", sum(10, 20))


>===================================================================

Keywords In Python:

Keywords in Python are reserved words that have special meanings and purposes within the language. These keywords cannot be used as identifiers (variable names, function names, etc.) because they are part of the language syntax.

List of keywords in Python: 
 
False      await      else       import     pass   None       break      except     in         raise
True       class      finally    is         return   and        continues   for        lambda     try
as         def        from       nonlocal   while assert     del        global     not        with
async      elif       if         or         yield



Description of Keywords:


1.	Boolean Values: True, False, and None are used to represent truth values (True and False) and a null value (None).

2.	Control Flow: Keywords like if, else, elif, while, for, break, continue, pass, and return are used for controlling the flow of execution in programs.

3.	Defining Entities: def is used to define functions, class is used to define classes, and lambda is used to create anonymous functions.

4.	Exception Handling: try, except, finally, and raise are used for handling exceptions and errors in Python programs.

5.	Importing Modules: import and from are used to import modules and contents from modules.

6.	Context Managers: with is used to manage resources and contexts that need cleanup actions.

7.	Operators: and, or, and not are logical operators used for boolean operations.

8.	Asyncio: async, await, and nonlocal are used in asynchronous programming (async and await) and for accessing variables in outer scopes (nonlocal).

9.	Assertions: assert is used to assert or enforce certain conditions in the code.



===================================================================================================
NAMING CONVENTION OF VARIABLES - BEST PRACTICES : Variable Naming Rules:



1.	Variables names must start with a letter (a-z, A-Z) or an underscore (_).
2.	The remaining characters can be letters, numbers, or underscores.
3.	Variable names are case-sensitive (age, Age, and AGE are three different variables).
4.	Python keywords (like if, else, for, etc.) cannot be used as variable names.

5.  Variables can be classified into GLOBAL scope variables and LOCAL scope variables 
                based on their scope, which determines where in your code they can be accessed and modified.

================================================================				
Assigning Values to Variables:
You assign a value to a variable using the assignment operator =.
Examples:
# Assigning integers
age = 25

# Assigning floating-point numbers
height = 5.11

# Assigning strings
name = "Madhu"

# Assigning a boolean value
is_student = True

# Assigning a list
numbers = [1, 2, 3, 4, 5]

================================================================

LOCAL VS GLOBAL VARIABLES 


---------------------------------
Global Scope Variables
Global variables are defined outside of any function and can be accessed (read and modified) by any part of the code, including inside functions.

--------
Local Scope Variables

Local variables are defined within a function and are only accessible within the scope of that function. They cannot be accessed outside the function.

-----------
Global Variables and Local Variables Together:

Variables with the same name can exist both globally and locally, but they are treated as separate variables with different scopes.
Example:


------------------------------------------------- 
cat local_global.py

x = 10
y = 20

def add_numbers():
    x = 15
    y = 25  
    print(f"Sum of 2 numbers is:, {x + y}")


def multiply_numbers():
    global x
    x = 5
    y = 4  
    print(f"Product of 2 numbers is:, {x * y}")


add_numbers()
multiply_numbers()
print(f"Global Sum of 2 numbers is:, {x + y}")

===============================================================================================


MODULES & PACKAGES
   
   modules and packages are fundamental concepts used TO ORGANIZE AND STRUCTURE CODE
  
   A module is A SINGLE FILE (WITH A .PY EXTENSION) that contains Python code. It can include functions, classes, and variables. You can also include runnable code. Modules are used to organize related code into a single file and to promote code reusability.
   
 ----------------------------------------  
 # my_module.py
    

def greet(name):
    print(f"Hello, {name}!")


def add(a, b):
    result = a + b
    print(f"The sum of {a} and {b} is {result}")
----------------------------------------


# main.py

import my_module

my_module.greet("Madhukiran")
my_module.add(5, 10)
my_module.add(20, 30)
my_module.greet("Alice")    
my_module.add(7, 3)
my_module.greet("BATCH 17")


=======================================================================

PYTHON PACKAGE: 

A package is a way of organizing multiple related modules into a directory hierarchy. 
A PACKAGE IS A DIRECTORY THAT CONTAINS A SPECIAL FILE NAMED __INIT__.PY (WHICH CAN BE EMPTY) AND OTHER MODULES. 
The presence of __init__.py indicates that the directory should be treated as a package.


my_package/
    __init__.py
    module1.py
    module2.py
	module3.py

--------------
# module1.py

def function1():
    return "This is function 1 from module 1"

-----------

# module2.py

def function2():
    return "This is function 2 from module 2"

-----------

cat main.py

from my_package import module1, module2, module3

module1.func1()
module2.func2() 
module3.func3()

=================================================================================

DATE: 21 JAN 25









==========================================================================================================


============================================================================


23 JAN 26
QUIZ & 












=====================================================================================
23 JAN 26 

INTERVIEW QUESTIONS:


1. What are the different data types in Python?

Python supports the following built-in data types:

       1) Numbers
          - int     → 10, 25, -3
          - float   → 10.5, 3.14
          - complex → 2 + 3j
       
       2) String
          - Used to store text
          - Defined using single, double, or triple quotes
          Examples:
          'Hello'
          "Python"
          """Welcome"""
       
       3) List
          - Ordered, changeable, allows duplicates
          Example:
          ["us-east-1a", "us-east-1b", "us-east-1c"]
       
       4) Tuple
          - Ordered, unchangeable, allows duplicates
          Example:
          ("us-east-1a", "us-east-1b", "us-east-1c")
       
       5) Range
          - Represents a sequence of numbers
          Example:
          range(10) --> 0 - 9 
		  range (4,10)   ---> 4 , 9
       
       6) Set
          - Unordered, changeable, does not allow duplicates
          Example:
          {"us-east-1a", "us-east-1b", "us-east-1c"}
       
       7) Dictionary
          - Stores data in key-value pairs
          Example:
          {'person1': 'John', 'person2': 'Doe'}
    
-----------------------------------------------------------------------------	
          Use type() function to find the data type of a variable.
          Eg: type(variable_name)
       
          We can find dir(variable_name) to find the methods and attributes of a variable.

x = "30.0"
print(f"datatype of variable x is {type(x)}")



x = "30.0"
print(f"The methods /fucntions for  x is {dir(x)}")
-----------------------------------------------------------------------------

Q. What is the difference between List and Tuple?

A:
At a high level, both List and Tuple:
- Are ordered
- Are index-based
- Are iterable

    1) Mutability
       - List is mutable (can be changed)
         → Elements can be added, removed, or modified
       - Tuple is immutable (cannot be changed once created)

    2) Operations
       - List supports operations like append(), extend(), remove(), pop()
       - Tuple does not support modification operations

    3) Performance and Memory
       - Tuple is faster than List
       - Tuple consumes less memory compared to List

Summary:
- Use List when data needs to change
- Use Tuple when data should remain constant

-----------------------------------------------------------------------------
Q. What is the difference between List & Set?
A: List is an ordered collection of items and can contain duplicate items. 
   Set is an unordered collection of items and does not contain duplicate items.
   
   
-----------------------------------------------------------------------------

Q. How can I find memory utilization of a variable, list, or tuple?

A:
Use sys.getsizeof() from the sys module.

    import sys

    print(sys.getsizeof(variable_name))
    print(sys.getsizeof(my_list))
    print(sys.getsizeof(my_tuple))

Note:
- Memory is returned in bytes
- It shows only the object size, not nested elements

import sys

x = 10
my_list = [1, 2, 3]
my_tuple = (1, 2, 3)

print(sys.getsizeof(x))
print(sys.getsizeof(my_list))
print(sys.getsizeof(my_tuple))


------------------------------------------------------------------------


Q. What are the tools you can use for Python Practice?
A: There are multiple tools which can help us to do the python coding, but I use the following:
      - Visual Studio Code
      - Jupyter Notebook when I need to do some data analysis.
      - IPython for interactive python coding for running small code snippets.


------------------------------------------------------------------------

Q. Can I convert a List to a Set in Python?

A:
Yes, a List can be converted to a Set using the built-in set() function.

Example:
    my_list = ["apple", "banana", "apple", "cherry"]

    my_set = set(my_list)

    print(my_set)

Note:
- Sets automatically remove duplicate values
- Sets are unordered collections
------------------------------------------------------------------------

Q. How can I append items to a list in Python?

A:
You can add items to a list using the append() and insert() methods.

    1) append()
       - Adds an item to the end of the list

       Example:
           my_list.append("item")

    2) insert()
       - Adds an item at a specified index

       Example:
           my_list.insert(index, "item")

Example:
    my_list = ["apple", "banana"]

    my_list.append("cherry")
    my_list.insert(1, "orange")

    print(my_list)

-----------------------------------------------------------------------------------

Q. How can I remove an item from a list in Python?

A:
Items can be removed from a list using remove() and pop() methods.

    1) remove(value)
       - Removes the first occurrence of the specified value

       Example:
           my_list.remove("item")

    2) pop()
       - Removes and returns the last item from the list

       Example:
           my_list.pop()

    3) pop(index)
       - Removes and returns the item at the specified index

       Example:
           my_list.pop(index)

Example:
    my_list = ["apple", "banana", "cherry", "banana"]

    my_list.remove("banana")
    my_list.pop()
    my_list.pop(0)

    print(my_list)

-------------------------------------------------------------------------------
Q. How can I print keys and values of a dictionary in Python?

A:
Python provides multiple ways to access dictionary keys and values.

    1) Print all keys
       person.keys()

    2) Print all values
       person.values()

    3) Print keys and values together using a loop
       for k, v in person.items():
           print(k, "--->", v)

    4) Access a specific value using a key
       person.get("name")
       (or)
       person["name"]

Example:
    person = {
        "name": "John",
        "age": 30,
        "city": "New York"
    }

    print(person.keys())
    print(person.values())

    for k, v in person.items():
        print(k, "--->", v)

    print(person.get("name"))
    print(person["name"])

-----------------------------------------------------------------------------

Q. What libraries / modules / packages are you familiar with in Python?

A:
I am familiar with the following Python libraries and modules:

    1) boto3
       - AWS SDK for Python
       - Used to interact with AWS services like S3, EC2, DynamoDB

    2) json
       - Used for working with JSON data
       - Common functions:
           json.dumps()  → Convert Python object to JSON string
           json.loads()  → Convert JSON string to Python object



    4) requests
       - Used for making HTTP requests (GET, POST, PUT, DELETE)
	   
    9) os and sys modules
       - Used for interacting with the operating system
       - Examples:
           os.getenv()
           os.listdir()
           sys.argv
           sys.getsizeof()

    10) shutil
        - Used for high-level file operations
        - Examples:
            shutil.copy()
            shutil.move()
			shutil.copytree
            shutil.rmtree()

    11) psutil
        - Used for retrieving system and process information
        - Examples:
            CPU usage, memory usage, disk usage, process monitoring
	   

    5) flask / fastapi
       - Used for building REST APIs
       - FastAPI supports async APIs and automatic documentation

    6) faker
       - Used for generating fake test data

    7) uuid
       - Used for generating unique identifiers (UUIDs)

    8) python-dotenv (dotenv)
       - Used for loading environment variables from a .env file



    12) IPython
        - Used for interactive Python development and testing


For Data Analysis:
- matplotlib: For data visualization
- pandas: For data manipulation and analysis
- numpy: For numerical operations


----------------------------------------------------

Q. Where Did You Use Python? 

I mainly use Python for automation, cloud operations, and DevOps scripting.

I used Python and boto3 to identify unused AWS resources like stopped EC2 instances and unattached EBS volumes to optimize cloud costs.


cleanup_stopped_instances.py

import boto3

REGION = "us-east-1"

ec2 = boto3.client("ec2", region_name=REGION)

def get_stopped_instances():
    response = ec2.describe_instances(
        Filters=[
            {"Name": "instance-state-name", "Values": ["stopped"]}
        ]
    )

    instances = []
    for reservation in response["Reservations"]:
        for instance in reservation["Instances"]:
            instances.append(instance["InstanceId"])

    return instances


if __name__ == "__main__":
    stopped_instances = get_stopped_instances()

    if not stopped_instances:
        print("No stopped EC2 instances found.")
    else:
        print("Stopped EC2 Instances:")
        for instance_id in stopped_instances:
            print(instance_id)

        # Uncomment after confirmation
        # ec2.terminate_instances(InstanceIds=stopped_instances)
        # print("Stopped instances terminated successfully.")
		

---------------------------------------------------------------------------
cleanup_old_volumes.py


import boto3
from datetime import datetime, timezone, timedelta

REGION = "us-east-1"
DAYS_OLD = 7

ec2 = boto3.client("ec2", region_name=REGION)

cutoff_date = datetime.now(timezone.utc) - timedelta(days=DAYS_OLD)

def get_old_unattached_volumes():
    response = ec2.describe_volumes(            #### resonse is a dictionary here 
        Filters=[
            {"Name": "status", "Values": ["available"]}
        ]
    )

    volumes = []
    for volume in response["Volumes"]:
        if volume["CreateTime"] < cutoff_date:
>            volumes.append(volume["VolumeId"])

    return volumes


if __name__ == "__main__":
    old_volumes = get_old_unattached_volumes()

    if not old_volumes:
        print("No old unattached EBS volumes found.")
    else:
        print("Old Unattached EBS Volumes (>7 days):")
        for vol_id in old_volumes:
            print(vol_id)

        # Uncomment after confirmation
        # for vol_id in old_volumes:
        #     ec2.delete_volume(VolumeId=vol_id)
        # print("Old volumes deleted successfully.")



------------------------------------------------------------------------------

describe_instances()	Reservations → Instances
describe_volumes()	Volumes
describe_snapshots()	Snapshots





--------------------------------------------------------------------------------
Q HAVE YOU WORKED ON APIs USING PYTHON?

Answer:
Yes, I have worked on REST APIs using Python.

I have used frameworks like:
- Flask
- FastAPI
to build RESTful APIs.



I also used the Python requests library to consume external REST APIs.

For example, I integrated third-party APIs to fetch user data,
send information using POST requests, update data using PUT,
and remove records using DELETE calls. I also handled JSON responses
and validated HTTP status codes.

---------------------------------------------------------------------------------------------------

Q) What is the difference between List and Dictionary?

Answer:

    - A List is an ordered collection of items.
    - A List allows duplicate items.
    - List items are accessed using index numbers (0, 1, 2, ...).
    - A List is mutable (can be changed).

    - A Dictionary is an unordered collection of key-value pairs.
    - Dictionary items are accessed using keys, not indexes.
    - Dictionary does NOT allow duplicate keys.
    - Dictionary values can be duplicated.
    - A Dictionary is also mutable.

Simple Example:

    List Example:
        my_list = [10, 20, 20, 30]

    Dictionary Example:
        my_dict = {"name": "John", "age": 30, "city": "NY"}




---------------------------------------------------------------------------------------------------
Q. How to reverse a list  in multiple ways?
A: list.reverse() => It will reverse the list in place.
   list[::-1] => It will return the reversed list but does not modify the original list.
   reversed(list) => It will return the reversed list but does not modify the original list.


---------------------------------------------------------------------------------------------------
Q) How can I create a multiline string in Python?

Answer:

    - You can create a multiline string using triple quotes:
        - '''  (triple single quotes)
        - """  (triple double quotes)

    Example:

        s = '''This is a
        multiline string'''

        print(s)

    - Python will preserve the line breaks exactly as written.


---------------------------------------------------------------------------------------------------


Q. How can I take INPUT from the user in Python?
A: You can use input() function to take input from the user.
   Eg: name = input('Enter your name: ')


---------------------------------------------------------------------------------------------------
Q) How can I convert a string to a list?

Answer:

    - You can convert a string to a list using the split() method.
    - split() divides the string based on a separator (space, comma, etc.)

    Example:

        X = 'WELCOME TO DEVOPS/SRE TRAINING'

        # Split the string based on space
        result = X.split(' ')

        print(result)

    Output:
        ['WELCOME', 'TO', 'DEVOPS/SRE', 'TRAINING']
---------------------------------------------------------------------------------------------------

Q) Convert a list to a string?
A: X = ['WELCOME', 'TO', 'DEVOPS/SRE', 'TRAINING']
   ' '.join(X) => 'WELCOME TO DEVOPS/SRE TRAINING'


---------------------------------------------------------------------------------------------------


Q). How to extract info usin requests module?
A: import requests
   response = requests.get('https://jsonplaceholder.typicode.com/posts')
   print(response.status_code)
   print(response.json())
 ---------------------------------------------------------------------------------------------------

 
Q) How to handle exceptions in Python?

Answer:

    - In Python, exceptions are handled using:
        try
        except
        finally

    - The 'try' block contains code that may raise an exception.
    - The 'except' block catches the exception and handles it.
    - The 'finally' block always runs (optional), used for cleanup.

    Example:

        try:
            # Code that may raise an exception
            x = 10 / 0
        except Exception as e:
            print("Error:", e)
        finally:
            print("This block always runs.")

    Output:
        Error: division by zero
        This block always runs.

 ---------------------------------------------------------------------------------------------------
shutil 

Q) How to install a package in Python?
A: pip install package_name (or) pip3 install package_name  # Search in pypi.org

 ---------------------------------------------------------------------------------------------------

Q)Q) How to generate fake user data using Faker?

Answer:

    - You can use the Faker library to generate fake data such as:
        - Names
        - Emails
        - Addresses
        - Profiles
        - Phone numbers
        - And much more

    Example:

        from faker import Faker

        fake = Faker()

        print(fake.name())
        print(fake.email())
        print(fake.address())
        print(fake.profile())

    ----------------------------------------------

    # To generate 100 fake email addresses

        from faker import Faker

        fake = Faker()

        for i in range(100):
            print(fake.profile()['mail'])


  
 ---------------------------------------------------------------------------------------------------

Q. What are the day-to-day operations using Python for a DevOps engineer?

A:
A DevOps engineer uses Python mainly for automation, scripting,
cloud operations, and system monitoring.

Common day-to-day tasks include:

    1) Automation & Scripting
       - Automating repetitive tasks
       - Writing scripts for backups, cleanup, and deployments
       - Automating server provisioning and configuration

    2) Cloud Operations (AWS / Azure / GCP)
       - Managing cloud resources using SDKs like boto3 or Azure SDK
       - Creating, updating, and deleting resources (EC2, S3, VMs, storage)
       - Automating scaling and cost optimization tasks

    3) CI/CD Pipeline Support
       - Writing Python scripts used in Jenkins, GitHub Actions, GitLab CI
       - Automating build, test, and deployment steps
       - Validating artifacts before deployment

    4) Monitoring and Logging
       - Collecting system metrics (CPU, memory, disk) using psutil
       - Parsing and analyzing log files
       - Sending alerts and notifications

    5) Infrastructure Automation
       - Integrating Python with tools like Terraform and Ansible
       - Writing custom Ansible modules or helpers
       - Validating infrastructure state

    6) API Integration
       - Calling REST APIs using requests
       - Integrating with tools like Jira, Slack, ServiceNow
       - Automating ticket creation and status updates

    7) Configuration and Secrets Management
       - Managing environment variables using python-dotenv
       - Reading configuration files (JSON, YAML)
       - Securing secrets and credentials

    8) File and System Operations
       - Working with files and directories using os and shutil
       - Archiving, copying, and cleaning files
       - Managing permissions

    9) Troubleshooting and Debugging
       - Writing quick scripts to debug production issues
       - Checking service health and process status
       - Analyzing failures and root cause

    10) Reporting and Notifications
        - Generating reports from logs or metrics
        - Sending email or Slack notifications
        - Creating dashboards or summaries
		
		




